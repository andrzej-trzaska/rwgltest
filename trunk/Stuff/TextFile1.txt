#pragma region includes
#include <vector>
#include <stdlib.h>
#include <math.h>

#ifdef __APPLE__
#include <OpenGL/OpenGL.h>
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif
#include <al.h>
#include <AL/alut.h>
#include <SOIL.h>

#include "ObjMesh.h"
#pragma endregion

#pragma region pragma comments
#pragma comment(lib, "alut.lib")
#pragma comment(lib, "OpenAL32.lib")
#pragma comment(lib, "SOIL.lib")
#pragma endregion

#pragma region defines
#define NUM_BUFFERS         10
#define NUM_SOURCES         10
#define NUM_ENVIRONMENTS    1

#define FALSE               0
#define TRUE                1
#pragma endregion

#pragma region variables
//angle of rotation
float   xpos = 0, ypos = 0, zpos = 0, xrot = 0, yrot = 0, angle = 0.0;
float   cRadius = 10.0f;    //our radius distance from our character
int     lastx, lasty;

//positions of the cubes
float   position[10][3];

//textures
GLuint  texture[3];         //Storage For One Texture ( NEW )

//lights
GLfloat redDiffuseMaterial[] = { 1.0, 0.0, 0.0 };       //set the material to red
GLfloat whiteSpecularMaterial[] = { 1.0, 1.0, 1.0 };    //set the material to white
GLfloat greenEmissiveMaterial[] = { 0.0, 1.0, 0.0 };    //set the material to green
GLfloat whiteSpecularLight[] = { 1.0, 1.0, 1.0 };       //set the light specular to white
GLfloat blackAmbientLight[] = { 0.0, 0.0, 0.0 };        //set the light ambient to black
GLfloat whiteDiffuseLight[] = { 1.0, 1.0, 1.0 };        //set the diffuse light to white
GLfloat blankMaterial[] = { 0.0, 0.0, 0.0 };            //set the diffuse light to white
GLfloat lightPos0[] = { 4.0f, 5.0f, 8.0f, 1.0f };       //Positioned at (4, 0, 8)

//sounds
ALfloat listenerPos[] = { 0.0, 0.0, 4.0 };
ALfloat listenerVel[] = { 0.0, 0.0, 0.0 };
ALfloat listenerOri[] = { 0.0, 0.0, 1.0, 0.0, 1.0, 0.0 };
ALfloat source0Pos[] = { 0.0, 0.0, 0.0 };
ALfloat source0Vel[] = { 0.0, 0.0, 0.0 };
ALuint  buffer[NUM_BUFFERS];
ALuint  source[NUM_SOURCES];
ALuint  environment[NUM_ENVIRONMENTS];
ALsizei size, freq;
ALenum  format;
ALvoid  *data;

//meshes
ObjMesh *mesh;


// Maya Style Mouse Movement Global Variables
unsigned int g_bLMB=0, g_bMMB=0;
int g_iLastPosX, g_iLastPosY, g_iStepX, g_iStepY;
float g_fZoom   = 0.0f, g_fTransX = 0.0f, g_fTransY = 0.0f, g_fSpinX  = 0.001f, g_fSpinY  = 0.001f;
float lpos[4] = {0,10,0,1};
#pragma endregion

//=======================================================================================================================
//   Load Bitmaps And Convert To Textures
//=======================================================================================================================
//
bool LoadGLTextures(void) {
    //load an image file directly as a new OpenGL texture
    texture[0] = SOIL_load_OGL_texture("Data/NeHe.bmp", SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);
    if (texture[0] == 0) return false;
    texture[1] = SOIL_load_OGL_texture("Data/Glass.bmp", SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);
    if (texture[1] == 0) return false;
    texture[2] = SOIL_load_OGL_texture("Data/grass.jpg", SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);
    if (texture[2] == 0) return false;

    //Typical Texture Generation Using Data From The Bitmap
    //glBindTexture(GL_TEXTURE_2D, texture[0]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    return true;    //Return Success
}

//=======================================================================================================================
//   set the positions of the cubes
//=======================================================================================================================
//
void pickCubePositions(void) {
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 3; j++) {
            position[i][j] = rand() % 10 + 1;
        }
    }

    source0Pos[0] = position[0][0];
    source0Pos[1] = position[0][1];
    source0Pos[2] = position[0][2];
}

//=======================================================================================================================
//   positions the light
//=======================================================================================================================
//
void positionLight(void) {
    glLightfv(GL_LIGHT0, GL_SPECULAR, whiteSpecularLight);
    glLightfv(GL_LIGHT0, GL_AMBIENT, blackAmbientLight);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, whiteDiffuseLight);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
}

//=======================================================================================================================
//   draws plane
//=======================================================================================================================
//
void drawGround(void) {
    glBindTexture(GL_TEXTURE_2D, texture[2]);
    glBegin(GL_QUADS);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-100.0f, -1.0f, -100.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(100.0f, -1.0f, -100.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(100.0f, -1.0f, 100.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-100.0f, -1.0f, 100.0f);
    glEnd();
}

//=======================================================================================================================
//   draws cube
//=======================================================================================================================
//
void drawTexturedCube(void) {
    glPushMatrix();
    glBindTexture(GL_TEXTURE_2D, texture[1]);
    glBegin(GL_QUADS);
    glRotatef(45.0f, 1.0, 1.0, 1.0);

    //Front Face
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, 1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(1.0f, -1.0f, 1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(1.0f, 1.0f, 1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f, 1.0f, 1.0f);

    //Back Face
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f, 1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(1.0f, 1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(1.0f, -1.0f, -1.0f);

    //Top Face
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f, 1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, 1.0f, 1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(1.0f, 1.0f, 1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(1.0f, 1.0f, -1.0f);

    //Bottom Face
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(1.0f, -1.0f, 1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, 1.0f);

    //Right face
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(1.0f, 1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(1.0f, 1.0f, 1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(1.0f, -1.0f, 1.0f);

    //Left Face
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, 1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f, 1.0f, 1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f, 1.0f, -1.0f);

    glEnd();
    glPopMatrix();
}

//=======================================================================================================================
//   draw the cubes
//=======================================================================================================================
//
void drawCubes(void) {
    for (int i = 0; i < 10 - 1; i++) {
        glPushMatrix();
        glTranslated(position[i + 1][0] * 10, 0, position[i + 1][2] * 10);    //translate the cube

        drawTexturedCube();
        glPopMatrix();
    }
}

//=======================================================================================================================
//   init OpenAL
//=======================================================================================================================
//
void initAudio(void) {
    char    al_bool;

    glClearColor(0.0, 0.0, 0.0, 1.0);

    //alutInit(0, NULL);
    alListenerfv(AL_POSITION, listenerPos);
    alListenerfv(AL_VELOCITY, listenerVel);
    alListenerfv(AL_ORIENTATION, listenerOri);

    alGetError();   //clear error

    //Generate buffers, or no sound will be produced
    alGenBuffers(NUM_BUFFERS, buffer);

    if (alGetError() != AL_NO_ERROR) exit(1);

    alutLoadWAVFile("data/a.wav", &format, &data, &size, &freq, &al_bool);
    alBufferData(buffer[0], format, data, size, freq);
    alutUnloadWAV(format, data, size, freq);

    alGetError();   //clear error
    alGenSources(NUM_SOURCES, source);

    if (alGetError() != AL_NO_ERROR) exit(2);

    alSourcef(source[0], AL_PITCH, 1.0f);
    alSourcef(source[0], AL_GAIN, 1.0f);
    alSourcefv(source[0], AL_POSITION, source0Pos);
    alSourcefv(source[0], AL_VELOCITY, source0Vel);
    alSourcei(source[0], AL_BUFFER, buffer[0]);
    alSourcei(source[0], AL_LOOPING, AL_TRUE);
}

//=======================================================================================================================
//   init OpenGL
//=======================================================================================================================
//
void initRendering(void) {
    glClearColor(0.5f,0.5f,0.5f,0.0f);
    glShadeModel(GL_SMOOTH);    //set the shader to smooth shader
    glEnable(GL_LIGHTING);      //enable the lighting
    glEnable(GL_LIGHT0);        //enable LIGHT0, our Diffuse Light
    glEnable(GL_DEPTH_TEST);    //Enables Depth Testing
    glEnable(GL_TEXTURE_2D);    //Enable Texture Mapping ( NEW )
    //glEnable(GL_CULL_FACE);

    //Setup Material Porperties & colours for the light
    {
        float Ambient[] = {0.4f,0.4f,0.4f,0.0f};
        float Diffuse[] = {0.75f,0.75f,0.75f,0.0f};
        glMaterialfv(GL_FRONT,GL_AMBIENT,Ambient);
        glMaterialfv(GL_FRONT,GL_DIFFUSE,Diffuse);
    }
    {
        float Ambient[] = {0.4f,0.4f,0.4f,0.0f};
        float Diffuse[] = {0.95f,0.95f,0.95f,0.0f};
        glLightfv(GL_LIGHT0,GL_AMBIENT,Ambient);
        glLightfv(GL_LIGHT0,GL_DIFFUSE,Diffuse);
    }


    //glEnable(GL_COLOR_MATERIAL);
    //glDepthFunc(GL_LEQUAL);     //The Type Of Depth Testing To Do
    //glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);  //Really Nice Perspective Calculations
    //glColor4f(1.0f, 1.0f, 1.0f, 0.5);   //Full Brightness. 50% Alpha
    //glBlendFunc(GL_SRC_ALPHA, GL_ONE);  //Set The Blending Function For Translucency
}

//=======================================================================================================================
//   initialization
//=======================================================================================================================
//
void init(void) {
    pickCubePositions();
    initRendering();    //clear the color buffer and the depth buffer
    LoadGLTextures();
    initAudio();
    alSourcePlay(source[0]);
}

//=======================================================================================================================
//	Function to impliment the transform required for the Maya Mouse movement
//=======================================================================================================================
//
void DoTransform(void) {
    glLoadIdentity();
    //gluLookAt(0,1,50,0,0,0,0,1,0);
    glTranslatef(g_fTransX,g_fTransY,g_fZoom);
    glRotatef   (g_fSpinX,1.0f,0.0f,0.0f);
	glRotatef   (g_fSpinY,0.0f,1.0f,0.0f);
	glTranslated(-xpos, 0.0f, -zpos);   //translate the screen to the position of our camera

}

//=======================================================================================================================
//	DoTransform2
//=======================================================================================================================
//
void DoTransform2() {

	glTranslatef(0.0f, 0.0f, -cRadius);
	//glTranslated(xpos, 0.0f, zpos);   //translate the screen to the position of our camera
	glRotatef(xrot, 1.0f, 0.0f, 0.0f);
	glRotatef(yrot, 0.0f, 1.0f, 0.0f);     //rotate our camera on the y-axis (up and down)
    //glColor3f(0.0f, 0.5f, 0.0f);
    drawTexturedCube();
    //glTranslated(-xpos, 0.0f, -zpos);   //translate the screen to the position of our camera
}

//=======================================================================================================================
//   display func
//=======================================================================================================================
//
void display(void) {
    //glClearColor(0.0, 0.5, 1.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //DoTransform();
    DoTransform2();
    //glLoadIdentity();
    glLightfv(GL_LIGHT0, GL_POSITION, lightPos0);
    //positionLight();


    //mesh->DrawMe();

    drawGround();
    drawCubes();        //call the cube drawing function
    glutSwapBuffers();  //swap the buffers
    //angle++;            //increase the angle
}

//=======================================================================================================================
//   reshape func
//=======================================================================================================================
//
void reshape(int w, int h) {
    glViewport(0, 0, (GLsizei) w, (GLsizei) h); //set the viewport to the current window specifications
    glMatrixMode(GL_PROJECTION);    //set the matrix to projection
    glLoadIdentity();
    gluPerspective(60, (GLfloat) w / (GLfloat) h, 0.1, 100.0);  //set the perspective (angle of sight, width, height,
    ///, depth)
    glMatrixMode(GL_MODELVIEW); //set the matrix back to model
}


//=======================================================================================================================
//	GLUT Callback function to deal with button presses and releases of the mouse
//=======================================================================================================================
//
void ButtonPress(int button,int state,int x,int y) {
    if (state == GLUT_DOWN) {
        g_iLastPosX = x;
        g_iLastPosY = y;
        switch (button) {
        case GLUT_LEFT_BUTTON:
            g_bLMB = 1;
            break;
        case GLUT_MIDDLE_BUTTON:
        case GLUT_RIGHT_BUTTON:
            g_bMMB = 1;
            break;
        default:
            break;
        }
    } else {
        switch (button) {
        case GLUT_LEFT_BUTTON:
            g_bLMB = 0;
            break;
        case GLUT_MIDDLE_BUTTON:
        case GLUT_RIGHT_BUTTON:
            g_bMMB = 0;
            break;
        default:
            break;
        }
    }
    glutPostRedisplay();

}

//=======================================================================================================================
//   mouse func
//=======================================================================================================================
//
void mouseMovement(int x, int y) {
    int diffx = x - lastx;  //check the difference between the current x and the last x position
    int diffy = y - lasty;  //check the difference between the current y and the last y position

    lastx = x;  //set lastx to the current x position
    lasty = y;  //set lasty to the current y position
    xrot += diffy;  //set the xrot to xrot with the addition of the difference in the y position
    yrot += diffx;  //set the xrot to yrot with the addition of the difference in the x position
}

//=======================================================================================================================
//   GLUT Callback function to deal with mouse movement
//=======================================================================================================================
//
void MouseMotion(int x,int y) {
    g_iStepX = x-g_iLastPosX;
    g_iStepY = y-g_iLastPosY;

    if (g_bLMB && g_bMMB) {
        g_fZoom += 0.2f*g_iStepX;
    } else if (g_bLMB) {
        g_fSpinX += 0.5f*g_iStepY;
        g_fSpinY += 0.5f*g_iStepX;
    } else if (g_bMMB) {
        g_fTransX  += 0.2f*g_iStepX;
        g_fTransY  -= 0.2f*g_iStepY;
    }

    g_iLastPosX = x;
    g_iLastPosY = y;
    glutPostRedisplay();
}

//=======================================================================================================================
//   keyboard func
//=======================================================================================================================
//
void keyboard(unsigned char key, int x, int y) {
    if (key == 'q') {
        xrot += 1;
        if (xrot > 360) xrot -= 360;
    }

    if (key == 'z') {
        xrot -= 1;
        if (xrot < -360) xrot += 360;
    }

    if (key == 'w') {
        float   xrotrad, yrotrad;

        yrotrad = (yrot / 180 * 3.141592654f);
        xrotrad = (xrot / 180 * 3.141592654f);
        xpos += sin(yrotrad);
        zpos -= cos(yrotrad);
        ypos -= sin(xrotrad);

        listenerPos[0] = xpos;
        listenerPos[2] = zpos;
        alListenerfv(AL_POSITION, listenerPos);
    }

    if (key == 's') {
        float   xrotrad, yrotrad;

        yrotrad = (yrot / 180 * 3.141592654f);
        xrotrad = (xrot / 180 * 3.141592654f);
        xpos -= sin(yrotrad);
        zpos += cos(yrotrad);
        ypos += sin(xrotrad);

        listenerPos[0] = xpos;
        listenerPos[2] = zpos;
        alListenerfv(AL_POSITION, listenerPos);
    }

    if (key == 'a') {
        float   yrotrad;

        yrotrad = (yrot / 180 * 3.141592654f);
        xpos -= cos(yrotrad) * 0.2;
        zpos -= sin(yrotrad) * 0.2;

        listenerPos[0] = xpos;
        listenerPos[2] = zpos;
        alListenerfv(AL_POSITION, listenerPos);
    }

    if (key == 'd') {
        float   yrotrad;

        yrotrad = (yrot / 180 * 3.141592654f);
        xpos += cos(yrotrad) * 0.2;
        zpos += sin(yrotrad) * 0.2;

        listenerPos[0] = xpos;
        listenerPos[2] = zpos;
        alListenerfv(AL_POSITION, listenerPos);
    }

    if (key == 27) {
        exit(0);
    }
}

//=======================================================================================================================
//   entry point
//=======================================================================================================================
//
int main(int argc, char **argv) {
    ObjMesh *mesh = new ObjMesh("./Data/girl.obj");
    //ObjMesh *mesh = new ObjMesh("./Data/torus.obj");

    alutInit(&argc, argv);
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH);
    glutInitWindowSize(500, 500);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("A basic OpenGL Window");
    glutFullScreen();
    glutSetCursor(GLUT_CURSOR_NONE);
    init();
    glutIdleFunc(display);
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutMouseFunc(ButtonPress);
    //glutMotionFunc (MouseMotion);
    glutPassiveMotionFunc(mouseMovement);   //check for mouse movement
    glutKeyboardFunc(keyboard);
    glutMainLoop();
    return 0;
}
